//  
//  JEngine
//  Version: 0.0.0
//  

(function() {
  var JEngine = {};
  var root = this;
  root.JEngine = JEngine;

(function() {JEngine.Utils = {};})();

(function() {// Regular expression used to split event strings.
var eventSplitter = /\s+/;

// Implement fancy features of the Events API such as multiple event
// names `"change blur"` and jQuery-style event maps `{change: action}`
// in terms of the existing API.
var eventsApi = function (obj, action, name, rest) {
  var key, names, i, l;
  if (!name) {
    return true;
  }

  // Handle event maps.
  if (typeof name === 'object') {
    for (key in name) {
      if (name.hasOwnProperty(key)) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
    }
    return false;
  }

  // Handle space separated event names.
  if (eventSplitter.test(name)) {
    names = name.split(eventSplitter);
    for (i = 0, l = names.length; i < l; i++) {
      obj[action].apply(obj, [names[i]].concat(rest));
    }
    return false;
  }

  return true;
};

// A difficult-to-believe, but optimized internal dispatch function for
// triggering events. Tries to keep the usual cases speedy (most internal
// Backbone events have 3 arguments).
var triggerEvents = function (events, args) {
  var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
  switch (args.length) {
    case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
    case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
    case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
    case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
    default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
  }
};

var Events = JEngine.Utils.Events = {
  // Bind an event to a `callback` function. Passing `"all"` will bind
  // the callback to all events fired.
  on: function (name, callback, ctx) {
    if (!eventsApi(this, 'on', name, [callback, ctx]) || !callback) return this;
    this._events || (this._events = {});
    var events = this._events[name] || (this._events[name] = []);
    events.push({callback: callback, ctx: ctx || this});
    return this;
  },

  // Bind an event to only be triggered a single time. After the first time
  // the callback is invoked, it will be removed.
  once: function (name, callback, ctx) {
    if (!eventsApi(this, 'once', name, [callback, ctx]) || !callback) return this;
    var self = this;
    var once = _.once(function() {
      self.off(name, once);
      callback.apply(this, arguments);
    });
    once._callback = callback;
    return this.on(name, once, ctx);
  },

  // Remove one or many callbacks. If `ctx` is null, removes all
  // callbacks with that function. If `callback` is null, removes all
  // callbacks for the event. If `name` is null, removes all bound
  // callbacks for all events.
  off: function (name, callback, ctx) {
    var retain, ev, events, names, i, l, j, k;
    if (!this._events || !eventsApi(this, 'off', name, [callback, ctx])) return this;
    if (!name && !callback && !ctx) {
      this._events = {};
      return this;
    }

    names = name ? [name] : _.keys(this._events);
    for (i = 0, l = names.length; i < l; i++) {
      name = names[i];
      if (events = this._events[name]) {
        this._events[name] = retain = [];
        if (callback || ctx) {
          for (j = 0, k = events.length; j < k; j++) {
            ev = events[j];
            if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                (ctx && ctx !== ev.ctx)) {
              retain.push(ev);
            }
          }
        }
        if (!retain.length) delete this._events[name];
      }
    }

    return this;
  },

  // Trigger one or many events, firing all bound callbacks. Callbacks are
  // passed the same arguments as `trigger` is, apart from the event name
  // (unless you're listening on `"all"`, which will cause your callback to
  // receive the true name of the event as the first argument).
  trigger: function (name, options, args) {
    if (!this._events) return this;
    if (typeof args == 'undefined') {
      args = options;
      options = {};
    }
    args || (args = []);
    if (!_.isArray(args)) {
      args = [args];
    }
    options || (options = {});
    if (!_.has(options, 'capture')) {
      options.capture = (this._eventsDefaultCapture || false);
    }
    if (!_.has(options, 'bubble')) {
      options.bubble = true;
    }
    if (!eventsApi(this, 'trigger', name, args)) return this;
    var events = this._events[name];
    var allEvents = this._events.all;
    if (events) triggerEvents(events, args);
    if (allEvents) triggerEvents(allEvents, arguments);
    if (options.bubble) {
      var argv = Array.prototype.slice.call(arguments);
      if (options.capture) {
        var children = (this.children || []);
        children.forEach(function(child) {
          if (typeof child.trigger === 'function') child.trigger.apply(child, argv);
        });
      } else {
        if (this.parent && typeof this.parent.trigger === 'function') this.parent.trigger.apply(this.parent, argv);
      }
    }
    return this;
  },

  // Tell this object to stop listening to either specific events ... or
  // to every object it's currently listening to.
  stopListening: function (obj, name, callback) {
    var listeners = this._listeners;
    if (!listeners) return this;
    var deleteListener = !name && !callback;
    if (typeof name === 'object') callback = this;
    if (obj) (listeners = {})[obj._listenerId] = obj;
    for (var id in listeners) {
      listeners[id].off(name, callback, this);
      if (deleteListener) delete this._listeners[id];
    }
    return this;
  }

};


var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

// Inversion-of-control versions of `on` and `once`. Tell *this* object to
// listen to an event in another object ... keeping track of what it's
// listening to.
_.each(listenMethods, function(implementation, method) {
  Events[method] = function(obj, name, callback) {
    var listeners = this._listeners || (this._listeners = {});
    var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));
    listeners[id] = obj;
    if (typeof name === 'object') callback = this;
    obj[implementation](name, callback, this);
    return this;
  };
});

// Aliases for backwards compatibility.
Events.bind   = Events.on;
Events.unbind = Events.off;})();

(function() {var Hierarchy = JEngine.Utils.Hierarchy = {
  add: function() {
    var self = this;
    self.children || (self.children = []);
    var children = _.flatten(slice.call(arguments));
    children.forEach(function(child) {
      if (!_.include(children, child)) {
        self.children.push(child);
        child.parent = self;
        child.trigger && child.trigger('added');
      }
    });
    self.trigger && self.trigger('addedChild');
    return this;
  },

  remove: function() {
    var self = this;
    self.children || (self.children = []);
    var children = _.flatten(slice.call(arguments));
    children.forEach(function(child) {
      if (!_.include(children, child)) {
        self.children = _.without(self.children, child);
        child.parent = undefined;
        child.trigger && child.trigger('removed');
      }
    });
    self.trigger && self.trigger('removeChild');
    return this;
  },

  removeSelf: function() {
    var self = this;
    if (self.parent && typeof self.parent.remove === 'function') {
      self.parent.remove(self);
    }
    self.parent = undefined;
    return this;
  },

  addTo: function(parent) {
    var self = this;
    if (parent && typeof parent.add === 'function') {
      parent.add(self);
    }
    return this;
  }
};})();

(function() {var Obj = JEngine.Utils.Obj = function(options) {
  this.handleOptions(options);
};

_.extend(Obj, {
  extend: function (protoProps, staticProps) {
    var parent = this,
        child,
        Parent;
    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function () { return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    Parent = function () { this.constructor = child; };
    Parent.prototype = parent.prototype;
    child.prototype = new Parent();

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) {
      _.extend(child.prototype, protoProps);
    }

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent;
    child.prototype.__super__ = parent.prototype;

    return child;
  }
});

_.extend(Obj.prototype, JEngine.Utils.Events, JEngine.Utils.Hierarchy, {
  handleOptions: function(options, defaults) {
    defaults || (defaults = this.defaults || {});
    options = options || {};
    this.options = _.defaults(options, defaults);
    return this;
  },

  _super: function () {
    var self = this,
        caller = arguments.callee.caller,
        funcName = _.detect(_.functions(self), function (attr) {
          return self[attr] === caller;
        }),
        args = arguments.length > 0 ? arguments : caller.arguments;
    if (funcName) {
      if (self.__super__) {
        var sClass = this.__super__;
        if (typeof sClass[funcName] === 'function') {
          sClass[funcName].apply(this, args);
        } else {
          console.warn('Super method for "' + funcName + '" not found!');
        }
      }
    }
  },

  clone: function() {
    
  }
});})();

(function() {_.extend(JEngine.Utils, {
  supportsWebGL: function() {
    try {
      var canvas = document.createElement('CANVAS');
      if (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')) {
        return true;
      }
    } catch (err) {
      return false;
    }
  },

  supportsCanvas: function() {
    try {
      var canvas = document.createElement('CANVAS');
      if (canvas.getContext('2d')) {
        return true;
      }
    } catch (err) {
      return false;
    }
  }
});})();

(function() {var class2type = {};
"Boolean Number String Function Array Date RegExp Object Error".split(" ").forEach(function(name, i) {
  class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

var hasOwn = function(class2type) {
  return class2type.hasOwnProperty;
};

_.extend(JEngine.Utils, {
  extend: function() {
    var options, name, src, copy, copyIsArray, clone,
      target = arguments[0] || {},
      i = 1,
      length = arguments.length,
      deep = false;

    // Handle a deep copy situation
    if ( typeof target === "boolean" ) {
      deep = target;
      target = arguments[1] || {};
      // skip the boolean and the target
      i = 2;
    }

    // Handle case when target is a string or something (possible in deep copy)
    if ( typeof target !== "object" && !utils.isFunction(target) ) {
      target = {};
    }

    for ( ; i < length; i++ ) {
      // Only deal with non-null/undefined values
      if ( (options = arguments[ i ]) != null ) {
        // Extend the base object
        for ( name in options ) {
          src = target[ name ];
          copy = options[ name ];

          // Prevent never-ending loop
          if ( target === copy ) {
            continue;
          }

          // Recurse if we're merging plain objects or arrays
          if ( deep && copy && ( utils.isPlainObject(copy) || (copyIsArray = utils.isArray(copy)) ) ) {
            if ( copyIsArray ) {
              copyIsArray = false;
              clone = src && utils.isArray(src) ? src : [];

            } else {
              clone = src && utils.isPlainObject(src) ? src : {};
            }

            // Never move original objects, clone them
            target[ name ] = utils.extend( deep, clone, copy );

          // Don't bring in undefined values
          } else if ( copy !== undefined ) {
            target[ name ] = copy;
          }
        }
      }
    }

    // Return the modified object
    return target;
  },

  isFunction: function( obj ) {
    return utils.type(obj) === "function";
  },

  isArray: Array.isArray,

  isNumeric: function( obj ) {
    return !isNaN(parseFloat(obj)) && isFinite(obj);
  },

  type: function( obj ) {
    if (obj == null) {
      return String(obj);
    }
    // Support: Safari <= 5.1 (functionish RegExp)
    return typeof obj === "object" || typeof obj === "function" ?
      class2type[ toString.call(obj) ] || "object" :
      typeof obj;
  },

  isWindow: function( obj ) {
    return obj != null && obj === obj.window;
  },

  isPlainObject: function( obj ) {
    // Not plain objects:
    // - Any object or value whose internal [[Class]] property is not "[object Object]"
    // - DOM nodes
    // - window
    if ( utils.type( obj ) !== "object" || obj.nodeType || utils.isWindow( obj ) ) {
      return false;
    }

    // Support: Firefox <20
    // The try/catch suppresses exceptions thrown when attempting to access
    // the "constructor" property of certain host objects, ie. |window.location|
    // https://bugzilla.mozilla.org/show_bug.cgi?id=814622
    try {
      if ( obj.constructor &&
          !hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
        return false;
      }
    } catch ( e ) {
      return false;
    }

    // If the function hasn't returned already, we're confident that
    // |obj| is a plain object, created by {} or constructed with new Object
    return true;
  },

  isEmptyObject: function( obj ) {
    var name;
    for ( name in obj ) {
      return false;
    }
    return true;
  },

  error: function( msg ) {
    throw new Error( msg );
  },

  noop: function() {},
});})();

(function() {JEngine.Renderers = {};})();

(function() {var NOT_IMPLEMENTED_ERROR = function(method) {
  return new Error('Renderers must respond to "'+ method +'"!');
}
var Renderer = JEngine.Renderers.Core = JEngine.Utils.Obj.extend({
  constructor: function(game) {
    this.setEngine(game);
  },

  setEngine: function(game) {
    this.game = game;
    this.setContext();
    return this;
  },

  setContext: function() {
    throw NOT_IMPLEMENTED_ERROR('setContext');
  },

  draw: function(/* */) {
    throw NOT_IMPLEMENTED_ERROR('draw');
  },

  drawSquare: function(/* */) {
    
  }
});})();

(function() {var Canvas = JEngine.Renderers.Canvas = JEngine.Renderers.Core.extend({
  setContext: function() {
    this.context = this.game.canvas.getContext('2d');
    return this;
  }
});})();

(function() {var Game = JEngine.Game = JEngine.Utils.Obj.extend({
  constructor: function(options) {
    this._super();
    this.rootUrl = this.options.rootUrl;
    this.urlPaths = {};
    this.processPackageJSON();
    this.setElement(this.options.element);
    this.start();
  },

  defaults: {
    element: 'body',
    rootUrl: document.location.origin,
    urlPaths: {
      root: '',
      scene: 'scene'
    },
  },

  processPackageJSON: function() {
    var self = this;
    this.getJSON('package.json', {
      async: false,
      success: function(json) {
        self.manifest = json;
        self.urlPaths = _.extend({}, self.urlPaths, self.options.urlPaths, self.manifest.urlPaths);
      }
    });
    return this;
  },

  getJSON: function(type, path, options) {
    var url;
    if (!options) {
      if (_.isObject(path)) {
        options = path;
        path = type;
        url = this.urlFor(path);
      } else {
        options = {};
        url = this.urlFor(type, path);
      }
    } else {
      url = this.urlFor(type, path);
    }
    options.url = url;
    options.dataFilter = function(data, dataType) {
      if ($.isPlainObject(data)) {
        return data
      }
      if (_.isString(data)) {
        try {
          return JSON.parse(data);
        } catch (err) {
          throw {
            name: 'Bad JSON Response', 
            message: 'Failed to parse response from '+ url
          };
        }
      } else {
        throw {
          name: 'Bad JSON Response', 
          message: 'Response from '+ url +' was in the wrong format ['+ dataType +']'
        };
      }
    };
    return $.ajax(options);
  },

  urlFor: function(type, path) {
    if (!path) {
      path = type;
      type = 'root'
    }
    return _.compact([this.rootUrl, this.urlPaths[type], path]).join('/');
  },

  setElement: function(value) {
    var elem = $(value);
    this.$element = elem;
    this.element = elem.get(0);
    this.$element.data({jengine: this});
    return this;
  },

  $: function(selector) {
    return this.$element.find(selector);
  },

  start: function() {
    this.scene || this.loadScene(this.options.scene || this.manifest.scene);
    this.scene.start();
    return this;
  },

  loadScene: function(scene) {
    this.scene && this.scene.unload();
    this.scene = new JEngine.Scene(this, scene);
    return this;
  }
});})();

(function() {var Scene = JEngine.Scene = JEngine.Utils.Obj.extend({
  constructor: function(game, scene, options) {
    if (this instanceof JEngine.Scene) {
      this._super(options);
      this.game = game;
      this.gameObjects = [];
      this.setManifest(scene);
    } else {
      if (scene instanceof JEngine.Scene) {
        scene.game = game;
        return scene;
      } else {
        return new JEngine.Scene(game, scene, options);
      }
    }
  },

  setManifest: function(scene) {
    if (scene) {
      if (_.isObject(scene)) {
        this.manifest = scene;
        this.load();
      } else {
        var self = this;
        this.game.getJSON('scene', scene, function(json) {
          self.manifest = json;
          self.load();
        });
      }
    } else {
      this.load();
    }
  },

  load: function() {
    console.log(this.manifest);
    this.fixedFrameRate = this.manifest.fixedFrameRate || 30;
    return this;
  },

  start: function() {
    if (!this.game) throw new Error('JEngine Scene cannot start without a game.');
    var self = this;
    var lastUpdateFrameTime = (new Date).valueOf();
    var lastFixedUpdateFrameTime = lastUpdateFrameTime;
    self.updateLoop = setInterval(function() {
      var newUpdateFrameTime = (new Date).valueOf();
      var frameTime = newUpdateFrameTime - lastUpdateFrameTime;
      lastUpdateFrameTime = newUpdateFrameTime;
      _.each(self.gameObjects, function(gameObject) {
        gameObject.trigger('update', frameTime);
      });
      // this.draw();
    }, 0);
    self.fixedUpdateLoop = setInterval(function() {
      var newFixedUpdateFrameTime = (new Date).valueOf();
      var frameTime = newFixedUpdateFrameTime - lastFixedUpdateFrameTime;
      lastFixedUpdateFrameTime = newFixedUpdateFrameTime;
      _.each(self.gameObjects, function(gameObject) {
        gameObject.trigger('fixedUpdate', frameTime);
      });
      // this.draw();
    }, 1000 / self.fixedFrameRate);
    return self;
  }
}, {
  Load: function(scene, options) {
    return JEngine.Scene(false, scene, options);
  }
});})();

(function() {var GameObject = JEngine.GameObject = JEngine.Utils.Obj.extend({
  constructor: function(scene, manifest) {
    this.scene = scene;
    this.game = this.scene.game;
    this.on('update', this.update);
    this.on('fixedUpdate', this.fixedUpdate);
    this.setManifest(manifest);
  },

  update: function(frameTime) {
    console.log('Update: '+frameTime);
  },

  fixedUpdate: function(frameTime) {
    console.log('Fixed Update: '+frameTime);
  },

  setManifest: function(game_object) {
    if (game_object) {
      if (_.isObject(game_object)) {
        this.manifest = game_object;
        this.load();
      } else {
        var self = this;
        this.game.getJSON('game_object', game_object, function(json) {
          self.manifest = json;
          self.load();
        });
      }
    } else {
      this.load();
    }
  },

  load: function() {
    console.log(this.manifest);
    return this;
  },

  translate: function(position) {
    this.position = position;
    return this;
  },

  rotate: function(rotation) {
    this.rotation = rotation;
    return this;
  },

  scale: function(scale) {
    this.scale = scale;
    return this;
  }
}, {
  Create: function(manifest, position, rotation, scale) {
    var gameObject = new this(manifest);
    gameObject.translate(position);
    gameObject.rotate(rotation);
    gameObject.scale(scale);
    return gameObject;
  }
});})();

}).call(this);